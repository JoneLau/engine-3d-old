export default {
  'pbr_lighting.frag': 'struct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n};\n{{#directionalLightSlots}}\n  uniform vec3 dir_light{{id}}_direction;\n  uniform vec3 dir_light{{id}}_color;\n{{/directionalLightSlots}}\n{{#pointLightSlots}}\n  uniform vec3 point_light{{id}}_position;\n  uniform vec3 point_light{{id}}_color;\n  uniform float point_light{{id}}_range;\n{{/pointLightSlots}}\n{{#spotLightSlots}}\n  uniform vec3 spot_light{{id}}_position;\n  uniform vec3 spot_light{{id}}_direction;\n  uniform vec3 spot_light{{id}}_color;\n  uniform vec2 spot_light{{id}}_spot;\n  uniform float spot_light{{id}}_range;\n{{/spotLightSlots}}\n// directional light\nLightInfo computeDirectionalLighting(\n  vec3 lightDirection,\n  vec3 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection);\n  ret.radiance = lightColor;\n  return ret;\n}\n// point light\nLightInfo computePointLighting(\n  vec3 lightPosition,\n  vec3 positionW,\n  vec3 lightColor,\n  float lightRange\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPosition - positionW;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor * attenuation;\n  return ret;\n}\n// spot light\nLightInfo computeSpotLight(\n  vec3 lightPosition,\n  vec3 positionW,\n  vec3 lightDirection,\n  vec3 lightColor,\n  vec2 lightSpot,\n  float lightRange\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPosition - positionW;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  float cosConeAngle = max(0., dot(lightDirection, -lightDir));\n  cosConeAngle = cosConeAngle < lightSpot.x ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle,lightSpot.y);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor * attenuation * cosConeAngle;\n  return ret;\n}',
  'phong_lighting.frag': 'struct LightInfo {\n  vec3 diffuse;\n  {{#useSpecular}}\n    vec3 specular;\n  {{/useSpecular}}\n};\nLightInfo computeDirectionalLighting(\n  vec3 lightDirection,\n  vec3 lightColor,\n  vec3 normal,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = -normalize(lightDirection);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl;\n  {{#useSpecular}}\n    vec3 dirH = normalize(viewDirection + lightDir);\n    ndh = max(0.0, dot(normal, dirH));\n    ndh = (ndl == 0.0) ? 0.0: ndh;\n    ndh = pow(ndh, max(1.0, glossiness));\n    lightingResult.specular = lightColor * ndh;\n  {{/useSpecular}}\n  return lightingResult;\n}\nLightInfo computePointLighting(\n  vec3 lightPosition,\n  vec3 lightColor,\n  float lightRange,\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = vec3(0, 0, 0);\n  float attenuation = 1.0;\n  lightDir = lightPosition - positionW;\n  attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  lightDir = normalize(lightDir);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl * attenuation;\n  {{#useSpecular}}\n    vec3 dirH = normalize(viewDirection + lightDir);\n    ndh = max(0.0, dot(normal, dirH));\n    ndh = (ndl == 0.0) ? 0.0: ndh;\n    ndh = pow(ndh, max(1.0, glossiness));\n    lightingResult.specular = lightColor * ndh * attenuation;\n  {{/useSpecular}}\n  return lightingResult;\n}\nLightInfo computeSpotLighting(\n  vec3 lightPosition,\n  vec3 lightDirection,\n  vec3 lightColor,\n  float lightRange,\n  vec2 lightSpot,\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = vec3(0, 0, 0);\n  float attenuation = 1.0;\n  float cosConeAngle = 1.0;\n  lightDir = lightPosition - positionW;\n  attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  lightDir = normalize(lightDir);\n  cosConeAngle = max(0., dot(lightDirection, -lightDir));\n  cosConeAngle = cosConeAngle < lightSpot.x ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle,lightSpot.y);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl * attenuation * cosConeAngle;\n  {{#useSpecular}}\n    vec3 dirH = normalize(viewDirection + lightDir);\n    ndh = max(0.0, dot(normal, dirH));\n    ndh = (ndl == 0.0) ? 0.0: ndh;\n    ndh = pow(ndh, max(1.0, glossiness));\n    lightingResult.specular = lightColor * ndh * attenuation * cosConeAngle;\n  {{/useSpecular}}\n  return lightingResult;\n}\n{{#directionalLightSlots}}\n  uniform vec3 dir_light{{id}}_direction;\n  uniform vec3 dir_light{{id}}_color;\n{{/directionalLightSlots}}\n{{#pointLightSlots}}\n  uniform vec3 point_light{{id}}_position;\n  uniform vec3 point_light{{id}}_color;\n  uniform float point_light{{id}}_range;\n{{/pointLightSlots}}\n{{#spotLightSlots}}\n  uniform vec3 spot_light{{id}}_position;\n  uniform vec3 spot_light{{id}}_direction;\n  uniform vec3 spot_light{{id}}_color;\n  uniform float spot_light{{id}}_range;\n  uniform vec2 spot_light{{id}}_spot;\n{{/spotLightSlots}}\nLightInfo getPhongLighting(\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo result;\n  result.diffuse = vec3(0, 0, 0);\n  {{#useSpecular}}\n    result.specular = vec3(0, 0, 0);\n  {{/useSpecular}}\n  LightInfo dirLighting;\n  {{#directionalLightSlots}}\n    dirLighting = computeDirectionalLighting(dir_light{{id}}_direction,dir_light{{id}}_color,normal, viewDirection, glossiness);\n    result.diffuse += dirLighting.diffuse;\n    {{#useSpecular}}\n      result.specular += dirLighting.specular;\n    {{/useSpecular}}\n  {{/directionalLightSlots}}\n  LightInfo pointLighting;\n  {{#pointLightSlots}}\n    pointLighting = computePointLighting(point_light{{id}}_position, point_light{{id}}_color, point_light{{id}}_range,\n                                         normal, positionW, viewDirection, glossiness);\n    result.diffuse += pointLighting.diffuse;\n    {{#useSpecular}}\n      result.specular += pointLighting.specular;\n    {{/useSpecular}}\n  {{/pointLightSlots}}\n  LightInfo spotLighting;\n  {{#spotLightSlots}}\n    spotLighting = computeSpotLighting(spot_light{{id}}_position, spot_light{{id}}_direction, spot_light{{id}}_color,\n                    spot_light{{id}}_range, spot_light{{id}}_spot,normal, positionW, viewDirection, glossiness);\n    result.diffuse += spotLighting.diffuse;\n    {{#useSpecular}}\n      result.specular += spotLighting.specular;\n    {{/useSpecular}}\n  {{/spotLightSlots}}\n  return result;\n}\n',
};