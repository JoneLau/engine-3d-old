export default {
  'common.frag': '\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define saturate(a) clamp( a, 0.0, 1.0 )',
  'gamma-correction.frag': '\nvec4 gammaToLinearSpaceRGBA(vec4 sRGBA) { \n  return sRGBA * (sRGBA * (sRGBA * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec4 linearToGammaSpaceRGBA(vec4 lRGBA) { \n  lRGBA = max(lRGBA, vec4(0.0));\n  return max(1.055 * pow(lRGBA, vec4(0.416666667)) - vec4(0.055), vec4(0.0));\n}\nvec3 gammaToLinearSpaceRGB(vec3 sRGB) { \n  return sRGB * (sRGB * (sRGB * 0.305306011 + 0.682171111) + 0.012522878);\n}\nvec3 linearToGammaSpaceRGB(vec3 lRGB) { \n  lRGB = max(lRGB, vec3(0.0));\n  return max(1.055 * pow(lRGB, vec3(0.416666667)) - vec3(0.055), vec3(0.0));\n}\nfloat gammaToLinearSpaceExact(float val) {\n  if (val <= 0.04045) {\n    return val / 12.92;\n  } else if (val < 1.0) {\n    return pow((val + 0.055) / 1.055, 2.4);\n  } else {\n    return pow(val, 2.2);\n  }\n}\nfloat linearToGammaSpaceExact(float val) {\n  if (val <= 0.0) {\n    return 0.0;\n  } else if (val <= 0.0031308) {\n    return 12.92 * val;\n  } else if (val < 1.0) {\n    return 1.055 * pow(val, 0.4166667) - 0.055;\n  } else {\n    return pow(val, 0.45454545);\n  }\n}',
  'packing.frag': '\nvec4 packDepthToRGBA(float depth) {\n  vec4 ret = vec4(1.0, 255.0, 65025.0, 160581375.0) * depth;\n  ret = fract(ret);\n  ret -= ret.yzww * vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0, 0.0);\n  return ret;\n}\nfloat unpackRGBAToDepth(vec4 color) {\n  return dot(color, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 160581375.0));\n}',
  'pbr-lighting.frag': '\nstruct LightInfo {\n  vec3 lightDir;\n  vec3 radiance;\n};\n#if NUM_DIR_LIGHTS > 0\n  #pragma for id in range(0, NUM_DIR_LIGHTS)\n    uniform vec3 dir_light{id}_direction;\n    uniform vec3 dir_light{id}_color;\n  #pragma endFor\n#endif\n#if NUM_POINT_LIGHTS > 0\n  #pragma for id in range(0, NUM_POINT_LIGHTS)\n    uniform vec3 point_light{id}_position;\n    uniform vec3 point_light{id}_color;\n    uniform float point_light{id}_range;\n  #pragma endFor\n#endif\n#if NUM_SPOT_LIGHTS > 0\n  #pragma for id in range(0, NUM_SPOT_LIGHTS)\n    uniform vec3 spot_light{id}_position;\n    uniform vec3 spot_light{id}_direction;\n    uniform vec3 spot_light{id}_color;\n    uniform vec2 spot_light{id}_spot;\n    uniform float spot_light{id}_range;\n  #pragma endFor\n#endif\nLightInfo computeDirectionalLighting(\n  vec3 lightDirection,\n  vec3 lightColor\n) {\n  LightInfo ret;\n  ret.lightDir = -normalize(lightDirection);\n  ret.radiance = lightColor;\n  return ret;\n}\nLightInfo computePointLighting(\n  vec3 lightPosition,\n  vec3 positionW,\n  vec3 lightColor,\n  float lightRange\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPosition - positionW;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor * attenuation;\n  return ret;\n}\nLightInfo computeSpotLighting(\n  vec3 lightPosition,\n  vec3 positionW,\n  vec3 lightDirection,\n  vec3 lightColor,\n  vec2 lightSpot,\n  float lightRange\n) {\n  LightInfo ret;\n  vec3 lightDir = lightPosition - positionW;\n  float attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  float cosConeAngle = max(0., dot(lightDirection, -lightDir));\n  cosConeAngle = cosConeAngle < lightSpot.x ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle,lightSpot.y);\n  ret.lightDir = normalize(lightDir);\n  ret.radiance = lightColor * attenuation * cosConeAngle;\n  return ret;\n}',
  'phong-lighting.frag': '\nstruct LightInfo {\n  vec3 diffuse;\n  vec3 specular;\n};\nLightInfo computeDirectionalLighting(\n  vec3 lightDirection,\n  vec3 lightColor,\n  vec3 normal,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = -normalize(lightDirection);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh;\n  return lightingResult;\n}\nLightInfo computePointLighting(\n  vec3 lightPosition,\n  vec3 lightColor,\n  float lightRange,\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = vec3(0, 0, 0);\n  float attenuation = 1.0;\n  lightDir = lightPosition - positionW;\n  attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  lightDir = normalize(lightDir);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl * attenuation;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh * attenuation;\n  return lightingResult;\n}\nLightInfo computeSpotLighting(\n  vec3 lightPosition,\n  vec3 lightDirection,\n  vec3 lightColor,\n  float lightRange,\n  vec2 lightSpot,\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo lightingResult;\n  float ndl = 0.0;\n  float ndh = 0.0;\n  vec3 lightDir = vec3(0, 0, 0);\n  float attenuation = 1.0;\n  float cosConeAngle = 1.0;\n  lightDir = lightPosition - positionW;\n  attenuation = max(0., 1.0 - length(lightDir) / lightRange);\n  lightDir = normalize(lightDir);\n  cosConeAngle = max(0., dot(lightDirection, -lightDir));\n  cosConeAngle = cosConeAngle < lightSpot.x ? 0.0 : cosConeAngle;\n  cosConeAngle = pow(cosConeAngle,lightSpot.y);\n  ndl = max(0.0, dot(normal, lightDir));\n  lightingResult.diffuse = lightColor * ndl * attenuation * cosConeAngle;\n  vec3 dirH = normalize(viewDirection + lightDir);\n  ndh = max(0.0, dot(normal, dirH));\n  ndh = (ndl == 0.0) ? 0.0: ndh;\n  ndh = pow(ndh, max(1.0, glossiness * 128.0));\n  lightingResult.specular = lightColor * ndh * attenuation * cosConeAngle;\n  return lightingResult;\n}\n#if NUM_DIR_LIGHTS > 0\n  #pragma for id in range(0, NUM_DIR_LIGHTS)\n    uniform vec3 dir_light{id}_direction;\n    uniform vec3 dir_light{id}_color;\n  #pragma endFor\n#endif\n#if NUM_POINT_LIGHTS > 0\n  #pragma for id in range(0, NUM_POINT_LIGHTS)\n    uniform vec3 point_light{id}_position;\n    uniform vec3 point_light{id}_color;\n    uniform float point_light{id}_range;\n  #pragma endFor\n#endif\n#if NUM_SPOT_LIGHTS > 0\n  #pragma for id in range(0, NUM_SPOT_LIGHTS)\n    uniform vec3 spot_light{id}_position;\n    uniform vec3 spot_light{id}_direction;\n    uniform vec3 spot_light{id}_color;\n    uniform float spot_light{id}_range;\n    uniform vec2 spot_light{id}_spot;\n  #pragma endFor\n#endif\nLightInfo getPhongLighting(\n  vec3 normal,\n  vec3 positionW,\n  vec3 viewDirection,\n  float glossiness\n) {\n  LightInfo result;\n  result.diffuse = vec3(0, 0, 0);\n  result.specular = vec3(0, 0, 0);\n  LightInfo dirLighting;\n  #if NUM_DIR_LIGHTS > 0\n    #pragma for id in range(0, NUM_DIR_LIGHTS)\n      dirLighting = computeDirectionalLighting(dir_light{id}_direction,dir_light{id}_color,normal, viewDirection, glossiness);\n      result.diffuse += dirLighting.diffuse;\n      result.specular += dirLighting.specular;\n    #pragma endFor\n  #endif\n  LightInfo pointLighting;\n  #if NUM_POINT_LIGHTS > 0\n    #pragma for id in range(0, NUM_POINT_LIGHTS)\n      pointLighting = computePointLighting(point_light{id}_position, point_light{id}_color, point_light{id}_range,\n                                          normal, positionW, viewDirection, glossiness);\n      result.diffuse += pointLighting.diffuse;\n      result.specular += pointLighting.specular;\n    #pragma endFor\n  #endif\n  LightInfo spotLighting;\n  #if NUM_SPOT_LIGHTS > 0\n    #pragma for id in range(0, NUM_SPOT_LIGHTS)\n      spotLighting = computeSpotLighting(spot_light{id}_position, spot_light{id}_direction, spot_light{id}_color,\n                      spot_light{id}_range, spot_light{id}_spot,normal, positionW, viewDirection, glossiness);\n      result.diffuse += spotLighting.diffuse;\n      result.specular += spotLighting.specular;\n    #pragma endFor\n  #endif\n  return result;\n}\n',
  'shadow-mapping.frag': '\n#if NUM_SHADOW_LIGHTS > 0\n  #pragma for id in range(0, NUM_SHADOW_LIGHTS)\n    uniform sampler2D shadowMap_{id};\n    uniform float darkness_{id};\n    uniform float depthScale_{id};\n    uniform float frustumEdgeFalloff_{id};\n    uniform float bias_{id};\n    uniform vec2 texelSize_{id};\n    varying vec4 pos_lightspace_{id};\n    varying float vDepth_{id};\n  #pragma endFor\n#endif\nfloat computeShadow(sampler2D shadowMap, vec4 pos_lightspace, float bias) {\n  vec3 projCoords = pos_lightspace.xyz / pos_lightspace.w;\n  projCoords = projCoords * 0.5 + 0.5;\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, projCoords.xy));\n  float currentDepth = projCoords.z;\n  float shadow = (currentDepth - bias > closestDepth) ? 0.0 : 1.0;\n  return shadow;\n}\nfloat computeFallOff(float esm, vec2 coords, float frustumEdgeFalloff) {\n  float mask = smoothstep(1.0 - frustumEdgeFalloff, 1.0, clamp(dot(coords, coords), 0.0, 1.0));\n  return mix(esm, 1.0, mask);\n}\nfloat computeShadowESM(sampler2D shadowMap, vec4 pos_lightspace, float vDepth, float depthScale, float darkness, float frustumEdgeFalloff) {\n  vec2 projCoords = pos_lightspace.xy / pos_lightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float closestDepth = unpackRGBAToDepth(texture2D(shadowMap, shadowUV));\n  \n  float esm = clamp(exp(-depthScale * (currentDepth - closestDepth)), 1.0 - darkness, 1.0);\n  return computeFallOff(esm, projCoords, frustumEdgeFalloff);\n}\nfloat computeShadowPCF(sampler2D shadowMap, vec4 pos_lightspace, float vDepth, float darkness, vec2 texelSize, float frustumEdgeFalloff) {\n  vec2 projCoords = pos_lightspace.xy / pos_lightspace.w;\n  vec2 shadowUV = projCoords * 0.5 + vec2(0.5);\n  if (shadowUV.x < 0.0 || shadowUV.x > 1.0 || shadowUV.y < 0.0 || shadowUV.y > 1.0) {\n    return 1.0;\n  }\n  float currentDepth = clamp(vDepth, 0.0, 1.0);\n  float visibility = 1.0;\n  vec2 poissonDisk[4];\n  poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n  poissonDisk[1] = vec2(0.94558609, -0.76890725);\n  poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n  poissonDisk[3] = vec2(0.34495938, 0.29387760);\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[0] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[1] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[2] * texelSize)) < currentDepth) visibility -= 0.25;\n  if (unpackRGBAToDepth(texture2D(shadowMap, shadowUV + poissonDisk[3] * texelSize)) < currentDepth) visibility -= 0.25;\n  return computeFallOff(min(1.0, visibility + 1.0 - darkness), projCoords, frustumEdgeFalloff);\n}',
  'skinning.vert': '\nattribute vec4 a_weights;\nattribute vec4 a_joints;\nuniform sampler2D u_jointsTexture;\nuniform float u_jointsTextureSize;\nmat4 getBoneMatrix(const in float i) {\n  float size = u_jointsTextureSize;\n  float j = i * 4.0;\n  float x = mod(j, size);\n  float y = floor(j / size);\n  float dx = 1.0 / size;\n  float dy = 1.0 / size;\n  y = dy * (y + 0.5);\n  vec4 v1 = texture2D(u_jointsTexture, vec2(dx * (x + 0.5), y));\n  vec4 v2 = texture2D(u_jointsTexture, vec2(dx * (x + 1.5), y));\n  vec4 v3 = texture2D(u_jointsTexture, vec2(dx * (x + 2.5), y));\n  vec4 v4 = texture2D(u_jointsTexture, vec2(dx * (x + 3.5), y));\n  return mat4(v1, v2, v3, v4);\n}\nmat4 skinMatrix() {\n  return\n    getBoneMatrix(a_joints.x) * a_weights.x +\n    getBoneMatrix(a_joints.y) * a_weights.y +\n    getBoneMatrix(a_joints.z) * a_weights.z +\n    getBoneMatrix(a_joints.w) * a_weights.w\n    ;\n}',
  'unpack-normal.frag': '\nvec3 unpackNormal(vec4 nmap) {\n  return nmap.xyz * 2.0 - 1.0;\n}',
};